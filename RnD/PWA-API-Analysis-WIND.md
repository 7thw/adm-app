---
title: PWA API Analysis & Integration Strategy
author: WIND
created: 2025-06-30
tags:
  - convex
  - api
  - pwa
  - integration
  - offline
  - streaming
---

# PWA API Analysis & Integration Strategy

## Current API Spec Overview

The current API spec generated by `npx convex-helpers ts-api-spec` reveals a well-structured API with three main namespaces:

1. **admin**: Admin-focused operations for content management
2. **auth**: Authentication and user management 
3. **subscribers**: PWA-specific functionality for end users

### Key PWA-Specific Endpoints

```typescript
subscribers: {
  getPublishedPlaylists: FunctionReference<...>;
  getPlaylistDetails: FunctionReference<...>;
  getUserPlaylists: FunctionReference<...>;
  createUserPlaylist: FunctionReference<...>;
  updateUserPlaylist: FunctionReference<...>;
  getUserPlayerSettings: FunctionReference<...>;
  updatePlayerSettings: FunctionReference<...>;
  updatePlaybackProgress: FunctionReference<...>;
}
```

## Missing Critical PWA Functionality

After analyzing the schema and API spec, I've identified several critical gaps for PWA functionality:

### 1. Media Streaming & Access Control

The current API lacks explicit endpoints for:
- Generating secure streaming URLs for audio/video content
- Handling range requests for partial content delivery
- Managing access control for premium content

### 2. Offline Support

No endpoints exist for:
- Downloading media for offline use
- Synchronizing offline activity when back online
- Managing the flattened JSONL strategy mentioned

### 3. User Profile & Subscription Management

Limited endpoints for:
- Updating user profiles
- Managing subscription status
- Handling subscription events

## Recommended API Additions

### 1. Media Access & Streaming

```typescript
subscribers: {
  // Get secure, time-limited streaming URL with proper headers
  getMediaStreamUrl: FunctionReference<
    "query",
    "public",
    { mediaId: Id<"medias">; quality?: "low" | "medium" | "high" },
    { url: string; expiresAt: number; contentType: string }
  >;
  
  // Download media for offline use
  requestMediaDownload: FunctionReference<
    "mutation",
    "public",
    { 
      mediaId: Id<"medias">; 
      quality: "low" | "medium" | "high";
    },
    { downloadUrl: string; expiresAt: number; size: number }
  >;
}
```

### 2. Offline Sync & JSONL Strategy

```typescript
subscribers: {
  // Get flattened JSONL representation of user playlists for offline use
  getUserPlaylistsJSONL: FunctionReference<
    "query",
    "public",
    { lastSyncTimestamp?: number },
    { jsonl: string; timestamp: number }
  >;
  
  // Sync offline activity back to server
  syncOfflineActivity: FunctionReference<
    "mutation",
    "public",
    { 
      events: string; // JSON string of offline events
      lastSyncTimestamp: number;
    },
    { success: boolean; conflicts?: any[] }
  >;
}
```

### 3. User Management

```typescript
subscribers: {
  // Get current user profile with subscription details
  getCurrentUserProfile: FunctionReference<
    "query",
    "public",
    {},
    any
  >;
  
  // Update user profile settings
  updateUserProfile: FunctionReference<
    "mutation",
    "public",
    {
      firstName?: string;
      lastName?: string;
      preferences?: any;
    },
    any
  >;
}
```

## R2 Integration for PWA

The current R2 implementation in `r2Upload.ts` is configured as a default export, which means it won't be included in the API spec generated by `convex-helpers ts-api-spec`.

### Issues with Current Implementation:

1. **Not Exposed in API**: The default export pattern doesn't expose named functions that would appear in the API spec.
2. **Limited Client Control**: The current implementation doesn't provide hooks for post-upload processing or custom file naming.
3. **No PWA-Specific Functions**: Missing functions for generating download URLs or handling offline media access.

### Recommended R2 Implementation for PWA:

```typescript
// convex/mediaStorage.ts
import { R2 } from "@convex-dev/r2";
import { components } from "./_generated/api";
import { query, mutation, action } from "./_generated/server";
import { v } from "convex/values";

// Create R2 instance
export const r2 = new R2(components.r2);

// Export client API functions that will be included in API spec
export const { generateUploadUrl, syncMetadata } = r2.clientApi({
  checkUpload: async (ctx, bucket) => {
    // Validate user has upload permissions
    const user = await ctx.auth.getUserIdentity();
    if (!user) {
      throw new Error("Not authenticated");
    }
    // Additional permission checks can be added here
  },
  onUpload: async (ctx, key) => {
    // Create placeholder media record
    // This will be included in the API spec
    return ctx.runMutation(api.admin.createMediaPlaceholder, { storageKey: key });
  },
});

// Media streaming function for PWA
export const getMediaStreamUrl = query({
  args: { 
    mediaId: v.id("medias"),
    quality: v.optional(v.union(v.literal("low"), v.literal("medium"), v.literal("high")))
  },
  handler: async (ctx, args) => {
    // Check authentication and subscription status
    const user = await ctx.auth.getUserIdentity();
    if (!user) {
      throw new Error("Not authenticated");
    }
    
    // Get media record
    const media = await ctx.db.get(args.mediaId);
    if (!media || !media.storageId) {
      throw new Error("Media not found or has no storage");
    }
    
    // Check access permissions
    if (!media.isPublic) {
      // Verify subscription status for premium content
      const userProfile = await ctx.db
        .query("userProfiles")
        .withIndex("by_clerk_user_id", q => q.eq("clerkUserId", user.subject))
        .unique();
        
      if (!userProfile || userProfile.subscriptionStatus !== "active") {
        throw new Error("Active subscription required");
      }
    }
    
    // Generate streaming URL with appropriate headers and expiration
    const url = await ctx.storage.getUrl(media.storageId, {
      expiresAfter: 60 * 60, // 1 hour in seconds
    });
    
    return { 
      url,
      expiresAt: Date.now() + (60 * 60 * 1000),
      contentType: media.contentType || "application/octet-stream"
    };
  },
});

// Download media for offline use
export const getMediaDownloadUrl = query({
  args: { 
    mediaId: v.id("medias"),
    quality: v.optional(v.union(v.literal("low"), v.literal("medium"), v.literal("high")))
  },
  handler: async (ctx, args) => {
    // Similar authentication and permission checks as getMediaStreamUrl
    
    // Generate download URL with longer expiration
    const url = await ctx.storage.getUrl(media.storageId, {
      expiresAfter: 24 * 60 * 60, // 24 hours in seconds
      download: true, // Force download headers
    });
    
    // Track download in analytics
    await ctx.runMutation(api.internal.trackMediaDownload, { 
      mediaId: args.mediaId,
      quality: args.quality || "high"
    });
    
    return { 
      url,
      expiresAt: Date.now() + (24 * 60 * 60 * 1000),
      size: media.fileSize || 0
    };
  },
});
```

## Flattened JSONL Strategy for Offline Support

The flattened JSONL strategy is an excellent approach for PWA offline capabilities. Here's how to implement it:

### 1. Create JSONL Export Function

```typescript
// convex/subscribers.ts
export const getUserPlaylistsJSONL = query({
  args: { lastSyncTimestamp: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const user = await ctx.auth.getUserIdentity();
    if (!user) {
      throw new Error("Not authenticated");
    }
    
    // Get user ID from auth
    const userProfile = await ctx.db
      .query("userProfiles")
      .withIndex("by_clerk_user_id", q => q.eq("clerkUserId", user.subject))
      .unique();
      
    if (!userProfile) {
      throw new Error("User profile not found");
    }
    
    // Get user playlists
    const userPlaylists = await ctx.db
      .query("userPlaylists")
      .withIndex("by_user", q => q.eq("userId", userProfile.userId))
      .collect();
      
    // Get related data (media selections, sections, etc.)
    // ... fetch related data
    
    // Build JSONL structure
    const jsonlLines = [
      // User profile line
      JSON.stringify({ type: "userProfile", data: userProfile }),
      
      // Playlists lines
      ...userPlaylists.map(playlist => 
        JSON.stringify({ type: "userPlaylist", data: playlist })
      ),
      
      // Media selections lines
      // ... other data
    ];
    
    return {
      jsonl: jsonlLines.join("\n"),
      timestamp: Date.now()
    };
  }
});
```

### 2. Create Sync Function for Offline Changes

```typescript
export const syncOfflineActivity = mutation({
  args: { 
    events: v.string(),
    lastSyncTimestamp: v.number()
  },
  handler: async (ctx, args) => {
    // Parse events
    const events = JSON.parse(args.events);
    
    // Process each event type
    const results = await Promise.all(events.map(async (event) => {
      switch (event.type) {
        case "playback_progress":
          // Update playback progress
          return ctx.db.patch(event.mediaSelectionId, {
            lastPosition: event.position,
            timeSpent: event.timeSpent
          });
        
        case "playlist_completion":
          // Update playlist completion
          // ...
          
        // Handle other event types
      }
    }));
    
    return {
      success: true,
      syncTimestamp: Date.now()
    };
  }
});
```

## Conclusion & Implementation Plan

To properly support the PWA with the API, I recommend:

1. **Refactor R2 Implementation**: Convert the default export in `r2Upload.ts` to a named export pattern with explicit functions that will be included in the API spec.

2. **Add Media Access Functions**: Create dedicated functions for streaming and downloading media with proper access control.

3. **Implement Offline Support**: Add the JSONL flattening strategy with sync capabilities.

4. **Enhance User Management**: Add more comprehensive user profile and subscription management functions.

5. **Document API Changes**: Create clear documentation for the PWA team on how to use these new endpoints.

The implementation should prioritize:
1. Media streaming functions (highest priority)
2. Offline support with JSONL
3. User profile enhancements

This approach will ensure the PWA has all necessary API endpoints while maintaining security and performance.